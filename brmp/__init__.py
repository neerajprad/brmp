import numpy as np
import pandas as pd

from brmp.formula import parse, Formula
from brmp.design import makedata, Metadata, metadata_from_df, code_lengths
from brmp.fit import Fit
from brmp.backend import Backend
from brmp.family import Family, Normal
from brmp.priors import build_prior_tree
from brmp.model_pre import build_model_pre
from brmp.model import build_model, model_repr
from brmp.pyro_backend import backend as pyro_backend
from brmp.backend import data_from_numpy

_default_backend = pyro_backend

def makedesc(formula, metadata, family, priors, code_lengths):
    assert type(formula) == Formula
    assert type(metadata) == Metadata
    assert type(family) == Family
    assert type(priors) == list
    model_desc_pre = build_model_pre(formula, metadata, family, code_lengths)
    prior_tree = build_prior_tree(model_desc_pre, priors)
    return build_model(model_desc_pre, prior_tree)

def defm(formula_str, df, family=None, priors=None, contrasts=None):
    assert type(formula_str) == str
    assert type(df) == pd.DataFrame
    assert family is None or type(family) == Family
    assert priors is None or type(priors) == list
    assert contrasts is None or type(contrasts) == dict

    family = family or Normal
    priors = priors or []
    contrasts = contrasts or {}

    # TODO: Consider accepting nested arrays as well as numpy arrays.
    # (If we do, convert to numpy arrays here in `defm`?)
    assert all(type(val) == np.ndarray and len(val.shape) == 2 for val in contrasts.values())

    formula = parse(formula_str)
    # Perhaps design matrices ought to always have metadata (i.e.
    # column names) associated with them, as in Patsy.
    metadata = metadata_from_df(df)
    desc = makedesc(formula, metadata, family, priors, code_lengths(contrasts))
    data = makedata(formula, df, metadata, contrasts)
    return DefmResult(formula, metadata, contrasts, desc, data)

# A wrapper around a pair of model and data. Has a friendly `repr` and
# makes it easy to fit the model.
class DefmResult:
    def __init__(self, formula, metadata, contrasts, desc, data):
        self.formula = formula
        self.metadata = metadata
        self.contrasts = contrasts
        self.desc = desc
        self.data = data

    def fit(self, backend=_default_backend, algo='nuts', **kwargs):
        assert type(backend) == Backend
        assert algo in ['prior', 'nuts', 'svi']
        return getattr(self.generate(backend), algo)(**kwargs)

    # Generate model code and data from this description, using the
    # supplied backend.
    def generate(self, backend=_default_backend):
        assert type(backend) == Backend
        model = backend.gen(self.desc)
        data = data_from_numpy(backend, self.data)
        return GenerateResult(self, backend, model, data)

    def prior(self, *args, **kwargs):
        return self.generate().prior(*args, **kwargs)

    def nuts(self, *args, **kwargs):
        return self.generate().nuts(*args, **kwargs)

    def svi(self, *args, **kwargs):
        return self.generate().svi(*args, **kwargs)

    def __repr__(self):
        return model_repr(self.desc)

# A wrapper around the result of calling DefmResult#generate. Exists
# to support the following interface:
#
# model.generate(<backend>).nuts(...)
# model.generate(<backend>).svi(...)
#
# This makes it possible to get at the code generated by a backend
# without running inference. For example:
#
# model.generate(<backend>).model.code
#
class GenerateResult():
    def __init__(self, defm_result, backend, model, data):
        self.defm_result = defm_result
        self.backend = backend
        self.model = model
        self.data = data

    def _run_algo(self, algo, *args, **kwargs):
        samples = getattr(self.backend, algo)(self.data, self.model, *args, **kwargs)
        return Fit(self.defm_result.formula, self.defm_result.metadata, self.defm_result.contrasts, self.data, self.defm_result.desc, self.model, samples, self.backend)

    def prior(self, num_samples=10, *args, **kwargs):
        return self._run_algo('prior', num_samples, *args, **kwargs)

    def nuts(self, iter=10, warmup=None, num_chains=1, *args, **kwargs):
        warmup = iter // 2 if warmup is None else warmup
        return self._run_algo('nuts', iter, warmup, num_chains, *args, **kwargs)

    def svi(self, iter=10, num_samples=10, *args, **kwargs):
        return self._run_algo('svi', iter, num_samples, *args, **kwargs)


def brm(formula_str, df, family=None, priors=None, **kwargs):
    return defm(formula_str, df, family, priors).fit(_default_backend, **kwargs)
